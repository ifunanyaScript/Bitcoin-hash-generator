# Bitcoin-hash-generator
### This is a simple python program that generates a new blockchain ___block hash___.<br>
The concept of mining bitcoin sometimes seems vague to a lot of people, but I'll try to simplify it.<br>
The blockchain from it's name is a link of several blocks of transactions, i.e There are thousands of tables of transactions<br>
like so;
| Sender      | Receiver    | Amount  |
| ----------- | ----------- |---------|
| user_id     | user_id     | $900    |
| user_id     | user_id     |$45678   |

The Bitcoin Core protocol limits each block to 1mb in size, thus, each block contains at most 4000 transactions.
These transaction tables pile up on the blockchain network, but they are only added to the actual chain of blocks (BlockChain),<br>
when there's is a valid block hash for the said transaction table. This is where bitcoin miners come in play. The end game of<br>
mining bitcoin, is to generate a new hash for the recent transaction tables. When said new hash is generated, the transaction table <br>
can now be added to the BlockChain as a valid block with the said miner having a reward of x bitcoins, depending on what year you mined it.

| Sender      | Receiver    | Amount  |
| ----------- | ----------- |---------|
| user_id     | user_id     | $900    |
| user_id     | user_id     |$45678   |
| REWARD     | ifunanyaScript     | 6.25BTC |


###### How is the hash generated?
The hash is generated by a cryptographic function called SHA256, specially chosen by Satoshi Nakomoto, the creator of the bitcoin protocol.<br>
The generation of the said hash is also dependent on certain fixed variables, which are the block number, a string of the entire transaction for the new
block, previous block hash, and the difficulty level.<br>
All these parameters are passed to the cryptographic function, which then generate the hash. 
###### But why is mining so hard?
Well it's because of the difficulty level. In simple sense the difficulty level is basically the number of zeros preceeding the hash, for example;
"0000000000jg990m1l3sv458m00lkrilkf66nmb0kl9a367klmno341v67uk0m07", the number of preceeding zeros is 10, so it's safe to say, the difficulty is level 10.<br> 
Currently on the blockchain the number of preceeding zeros required for a new hash is 19, such like;
"0000000000000000000jv458m00lkrilkf66nmb0kl9a367klmno341v67uk0m07"
<br>
The main reason for high difficulty is to secure the network from fraud.

###### How to generate the hash?
After passing the parameters to the cryptographic function, you would expect it to come up with a new valid hash right? Well it's not that easy. There's a catch! 
The __nonce__ which stands for number once. This nonce is the only parameter that can change while trying to generate a new valid hash. So you have to alter the
__nonce__ iteratively, until you arrive at a __nonce__ that gives the valid hash. This is why mining bitcoin is competitive. Everyone is continuously trying to<br>
guess the right __nonce__ that generates the valid hash for the new block.
<br>
Using a normal machine like a laptop or desktop would have a been a great idea, only when the difficulty was still low. However, in 2022, with such high difficulty,
it's almost a futile attempt to use a basic machine to attempt guessing the right nonce, because guessing this nonce requires a great deal of electrical and
computational resources.<br>
Most big time Bitcoin miners have special devices called __Bitcoin miner__, used to guess the nonce that generates the valid hash; These devices make the process a
lot faster as compared to a laptop or desktop.<br>
<br>
The valid hash for the new block is generated by iteratively changing the nonce while calling the cryptographic function, until you get a nonce that gives the valid
hash. <br>
I have built two python programs that can do this nonce guessing and generate a new valid hash. It is available in this repository. Be sure to check it out.<br>
‚≠ê this repo!
